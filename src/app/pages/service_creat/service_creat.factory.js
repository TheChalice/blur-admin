/** * Created by sorcerer on 2017/10/31. */(function () {    'use strict';    angular.module('BlurAdmin.pages.servicecreat')        .factory('serviceCreatPrepare', serviceCreatPrepare)        .factory('serviceCreatCreat', serviceCreatCreat)        function serviceCreatPrepare(Cookie) {            var namespace = Cookie.get('namespace');            function changestr(str) {                if (str.startsWith("/")) {                    return changestr(str.replace("/", ""))                }                return "/" + str            }            function geshihuan(unit, num) {                if (!num) {                }                if (unit === 'millcores') {                    return num ? parseFloat(num) + 'm' : false;                } else if (unit === 'cores') {                    return num ? parseFloat(num) : false;                } else if (unit === 'MB') {                    return num ? parseFloat(num) + 'Mi' : false;                } else if (unit === 'GB') {                    return num ? parseFloat(num) + 'Gi' : false;                }            }            var serviceCreatFactory = {};            serviceCreatFactory.imageChange=function (dc) {                angular.forEach(dc.spec.template.spec.containers, function (con) {                    if (con.isimageChange) {                        dc.spec.triggers.push(con.triggerImageTpl)                    }                })            }            serviceCreatFactory.prepareEnv=function (dc,evns) {                var containers = dc.spec.template.spec.containers;                var reg = new RegExp(/^[a-zA-Z_]+[a-zA-Z0-9_]*$/gi);                for (var i = 0; i < containers.length; i++) {                    var thisenv = angular.copy(evns);                    for (var k = 0; k < evns.length; k++) {                        if (!evns[k].name) {                            thisenv.splice(k, 1);                        }                    }                    containers[i].env = thisenv;                    for (var j = 0; j < containers[i].env.length; j++) {                        if (reg.test(containers[i].env[j].name) == false) {                            return false;                        }                    }                }            };            serviceCreatFactory.prepareTrigger=function (dc,configChange) {                if (configChange) {                    dc.spec.triggers.push({type: 'ConfigChange'});                }else {                    var arr=angular.copy(dc.spec.triggers)                    angular.forEach(dc.spec.triggers, function (trigger,i) {                        if (trigger) {                            if (trigger.type&&trigger.type==='ConfigChange') {                                arr.splice(i,1)                            }                        }                    })                    dc.spec.triggers=arr;                }            }            serviceCreatFactory.prepareDc=function (dc) {                var name = dc.metadata.name;                dc.metadata.labels.app = name;                dc.spec.selector.app = name;                dc.spec.selector.deploymentconfig = name;                dc.spec.template.metadata.labels.app = name;                dc.spec.template.metadata.labels.deploymentconfig = name;            };            serviceCreatFactory.prepareQuota=function (dc,switchquot,quota) {                if (switchquot) {                    angular.forEach(dc.spec.template.spec.containers, function (ports, i) {                        dc.spec.template.spec.containers[i].resources.requests.cpu = geshihuan(quota.cpu.request.cpuunit, quota.cpu.request.cpuquota)                        dc.spec.template.spec.containers[i].resources.limits.cpu = geshihuan(quota.cpu.limit.cpuunit, quota.cpu.limit.cpuquota)                        dc.spec.template.spec.containers[i].resources.requests.memory = geshihuan(quota.memory.request.memoryunit, quota.memory.request.memoryquota)                        dc.spec.template.spec.containers[i].resources.limits.memory = geshihuan(quota.memory.limit.memoryunit, quota.memory.limit.memoryquota)                        if (dc.spec.template.spec.containers[i].resources.requests.cpu === false) {                            delete dc.spec.template.spec.containers[i].resources.requests.cpu                        }                        if (dc.spec.template.spec.containers[i].resources.requests.memory === false) {                            delete dc.spec.template.spec.containers[i].resources.requests.memory                        }                        if (dc.spec.template.spec.containers[i].resources.limits.cpu === false) {                            delete dc.spec.template.spec.containers[i].resources.limits.cpu;                        }                        if (dc.spec.template.spec.containers[i].resources.limits.memory === false) {                            delete dc.spec.template.spec.containers[i].resources.limits.memory;                        }                        if (JSON.stringify(dc.spec.template.spec.containers[i].resources.limits) == "{}") {                            delete dc.spec.template.spec.containers[i].resources.limits                        }                        if (JSON.stringify(dc.spec.template.spec.containers[i].resources.requests) == "{}") {                            delete dc.spec.template.spec.containers[i].resources.requests                        }                        if (JSON.stringify(dc.spec.template.spec.containers[i].resources) == "{}") {                            delete dc.spec.template.spec.containers[i].resources                        }                    })                } else {                    angular.forEach(dc.spec.template.spec.containers, function (ports, i) {                        delete dc.spec.template.spec.containers[i].resources                    })                }            }            serviceCreatFactory.prepareVolume=function (dc) {                dc.spec.template.spec.volumes = []                angular.forEach(dc.spec.template.spec.containers, function (con, i) {                    if (!con.advanconfg) {                        delete dc.spec.template.spec.containers[i].secretsobj                    } else {                        con.volumeMounts = [];                        if (con.secretsobj.secretarr.length > 0) {                            angular.forEach(con.secretsobj.secretarr, function (secret, k) {                                if (dc.spec.template.spec.containers[i].secretsobj.secretarr[k].secret.secretName !== '名称' && dc.spec.template.spec.containers[i].secretsobj.secretarr[k].mountPath !== "") {                                    if (secret.mountPath.indexOf('/') !== 0) {                                        secret.mountPath = '/' + secret.mountPath                                    } else {                                        secret.mountPath = changestr(secret.mountPath)                                    }                                    secret.name = "con" + i + "secrat" + k;                                    var secretcopy = angular.copy(secret);                                    dc.spec.template.spec.volumes.push(secretcopy)                                    delete dc.spec.template.spec.containers[i].secretsobj.secretarr[k].secret                                    con.volumeMounts.push(dc.spec.template.spec.containers[i].secretsobj.secretarr[k])                                } else {                                    delete dc.spec.template.spec.containers[i].secretsobj.secretarr[k]                                }                            });                        }                        if (con.secretsobj.configmap.length > 0) {                            angular.forEach(con.secretsobj.configmap, function (config, k) {                                if (dc.spec.template.spec.containers[i].secretsobj.configmap[k].configMap.name !== '名称' && dc.spec.template.spec.containers[i].secretsobj.configmap[k].mountPath !== "") {                                    if (config.mountPath.indexOf('/') !== 0) {                                        config.mountPath = '/' + config.mountPath                                    } else {                                        config.mountPath = changestr(config.mountPath)                                    }                                    config.name = "con" + i + "config" + k;                                    var configcopy = angular.copy(config);                                    dc.spec.template.spec.volumes.push(configcopy)                                    delete dc.spec.template.spec.containers[i].secretsobj.configmap[k].configMap                                    con.volumeMounts.push(dc.spec.template.spec.containers[i].secretsobj.configmap[k])                                } else {                                    delete dc.spec.template.spec.containers[i].secretsobj.configmap[k]                                }                            });                        }                        if (con.secretsobj.persistentarr.length > 0) {                            angular.forEach(con.secretsobj.persistentarr, function (persistent, k) {                                if (dc.spec.template.spec.containers[i].secretsobj.persistentarr[k].persistentVolumeClaim.claimName !== '名称' && dc.spec.template.spec.containers[i].secretsobj.persistentarr[k].mountPath !== "") {                                    if (persistent.mountPath.indexOf('/') !== 0) {                                        persistent.mountPath = '/' + persistent.mountPath                                    } else {                                        persistent.mountPath = changestr(persistent.mountPath)                                    }                                    persistent.name = "con" + i + "persistent" + k;                                    var persistentcopy = angular.copy(persistent);                                    dc.spec.template.spec.volumes.push(persistentcopy)                                    delete dc.spec.template.spec.containers[i].secretsobj.persistentarr[k].persistentVolumeClaim.claimName                                    con.volumeMounts.push(dc.spec.template.spec.containers[i].secretsobj.persistentarr[k])                                } else {                                    delete dc.spec.template.spec.containers[i].secretsobj.persistentarr[k]                                }                            });                        }                        delete dc.spec.template.spec.containers[i].secretsobj                        angular.forEach(dc.spec.template.spec.volumes, function (volume, i) {                            delete dc.spec.template.spec.volumes[i].mountPath                        })                    }                })            };            return serviceCreatFactory;        }        function serviceCreatCreat(DeploymentConfig, $state, toastr, Cookie) {            var namespace = Cookie.get('namespace');            var serviceCreatCreat = {}            serviceCreatCreat.createDcfn = function (dc) {                DeploymentConfig.create({                    namespace: namespace                }, dc, function (res) {                    $state.go('service_detil', {name: dc.metadata.name});                }, function (res) {                    console.log('res', res);                    if (res.status === 409) {                        toastr.error('服务名重复', '创建DC失败');                    }else {                        toastr.error('参数错误', '创建DC失败');                    }                });            }            return serviceCreatCreat;        }})();