/** * Created by sorcerer on 2017/10/31. */(function () {    'use strict';    angular.module('BlurAdmin.pages.servicecreat')        .controller('servicecreatCtrl', servicecreatCtrl);    /** @ngInject */    function servicecreatCtrl(GLOBAL, $log, Cookie, $rootScope, $scope, Service, Route, $base64, secretskey, DeploymentConfig, $state, servicecreattemplate) {        $rootScope.namespace = Cookie.get('namespace');        $scope.portsArr = [];        $scope.envs = [];        $scope.dc = angular.copy(servicecreattemplate.dc)        $scope.containerTpl = angular.copy(servicecreattemplate.containerTpl)        $scope.horiz = angular.copy(servicecreattemplate.horiz)        $scope.service = angular.copy(servicecreattemplate.service)        $scope.route = angular.copy(servicecreattemplate.route)        $scope.switch = {            elastic: false,            route: false        };        $scope.checked = {            port: null,            cname: '系统域名',            host: '',            tlsset: 'None',            httpset: 'None',            zsfile: {key: '请选择证书', value: ''},            syfile: {key: '请选择证书', value: ''},            cafile: {key: '请选择证书', value: ''},            mcafile: {key: '请选择证书', value: ''},            suffix: '.' + $rootScope.namespace + GLOBAL.service_url        }        $scope.tlsset = {            setone: ['None', 'Edge', 'Passthrough', 'Re-encrypt'],            httpset: ['None', 'Allow', 'Redirect']        }        $scope.gotoadvan = function () {            $scope.nettap = $scope.nettap === '基本设置' ? '高级设置' : '基本设置';            $scope.checked.port = $scope.portsArr[0].containerPort + '(TCP)'        }        function prepareService(service, dc) {            service.metadata.name = dc.metadata.name;            service.metadata.labels.app = dc.metadata.name;            service.spec.selector.app = dc.metadata.name;            service.spec.selector.deploymentconfig = dc.metadata.name;        };        function createService(dc) {            prepareService($scope.service, dc);            var ps = [];            if ($scope.portsArr) {                var ports = $scope.portsArr;                for (var j = 0; j < ports.length; j++) {                    if (ports[j].hostPort) {                        var val = ports[j].protocol.toUpperCase()                        ps.push({                            name: ports[j].hostPort + '-' + ports[j].protocol.toLowerCase(),                            port: parseInt(ports[j].hostPort),                            protocol: val,                            targetPort: parseInt(ports[j].containerPort)                        });                    }                }            }            if (ps.length > 0) {                $scope.service.spec.ports = ps;            } else {                $scope.service.spec.ports = null;            }            Service.create({                namespace: $rootScope.namespace,                region: $rootScope.region            }, $scope.service, function (res) {                $scope.service = res;            }, function (res) {                $log.info("create service fail", res);                $state.go('console.service_detail', {name: dc.metadata.name});            });        };        function prepareDc(dc) {            var name = dc.metadata.name;            dc.metadata.labels.app = name;            dc.spec.selector.app = name;            dc.spec.selector.deploymentconfig = name;            dc.spec.template.metadata.labels.app = name;            dc.spec.template.metadata.labels.deploymentconfig = name;        };        function prepareVolume(dc) {            var containers = dc.spec.template.spec.containers;            for (var i = 0; i < containers.length; i++) {                var container = containers[i];                if (container.volumeMounts && container.volumeMounts.length == 0) {                    delete container["volumeMounts"];                }            }            if (dc.spec.template.spec.volumes.length == 0) {                delete dc.spec.template.spec["volumes"];            }        };        function prepareTrigger(dc) {            if ($scope.grid.configChange) {                dc.spec.triggers.push({type: 'ConfigChange'});            }        };        function prepareEnv(dc) {            var containers = dc.spec.template.spec.containers;            var reg = new RegExp(/^[a-zA-Z_]+[a-zA-Z0-9_]*$/gi);            for (var i = 0; i < containers.length; i++) {                var thisenv = angular.copy($scope.envs);                for (var k = 0; k < $scope.envs.length; k++) {                    if (!$scope.envs[k].name) {                        thisenv.splice(k, 1);                    }                }                containers[i].env = thisenv;                //console.log(containers[i]);                for (var j = 0; j < containers[i].env.length; j++) {                    if (reg.test(containers[i].env[j].name) == false) {                        $scope.checkEnv = true;                        return false;                    }                }            }        };        //  删除同名服务,创建dc之前执行该方法        function deleService() {            Service.delete({                namespace: $rootScope.namespace,                name: $scope.dc.metadata.name            }, function (res) {            })        }        //  删除同名路由,创建dc之前执行该方法        function deleRoute() {            Route.delete({                namespace: $rootScope.namespace,                name: $scope.dc.metadata.name            }, function (res) {            })        }        $scope.createDc = function () {            angular.forEach($scope.dc.spec.template.spec.containers, function (ports, i) {                if (ports.cando) {                    //delete $scope.dc.spec.template.spec.containers[i].cadoerr                } else {                    delete $scope.dc.spec.template.spec.containers[i].readinessProbe                }                if (ports.port) {                    delete $scope.dc.spec.template.spec.containers[i].port                }                if (ports.cando || ports.doset) {                    delete $scope.dc.spec.template.spec.containers[i].cando                    delete $scope.dc.spec.template.spec.containers[i].doset                }            })            //$rootScope.lding = true;            var dc = angular.copy($scope.dc);            var cons = angular.copy($scope.dc.spec.template.spec.containers);            var flog = 0;            for (var i = 0; i < dc.spec.template.spec.containers.length; i++) {                //$scope.dc.spec.template.spec.containers[i].name = dc.spec.template.spec.containers[i].strname;                delete dc.spec.template.spec.containers[i]["strname"];                if (dc.spec.template.spec.containers[i].isimageChange) {                    //console.log('111111111111');                    dc.spec.triggers.push(dc.spec.template.spec.containers[i].triggerImageTpl)                }                if (cons[i].ports) {                    var testlength = cons[i].ports.length;                    for (var k = 0; k < testlength; k++) {                        if (!cons[i].ports[k].containerPort) {                            cons[i].ports.splice(k, 1);                            k--;                            testlength--;                        } else {                            cons[i].ports[k].name = cons[i].ports[k].protocol + "-" + cons[i].ports[k].containerPort;                            cons[i].ports[k].protocol = cons[i].ports[k].protocol.toUpperCase()                        }                    }                }                dc.spec.template.spec.containers[i].ports = cons[i].ports;            }            prepareDc(dc);            //prepareVolume(dc);            //prepareTrigger(dc);            //prepareEnv(dc);            deleService();            deleRoute();            var clonedc = angular.copy(dc);            var arrimgs = [];            var arrisshow = [];            for (var i = 0; i < clonedc.spec.template.spec.containers.length; i++) {                arrisshow.push(clonedc.spec.template.spec.containers[i].isshow);                delete clonedc.spec.template.spec.containers[i]["commitId"];                delete clonedc.spec.template.spec.containers[i]["triggerImageTpl"];                delete clonedc.spec.template.spec.containers[i]["secretsobj"];                delete clonedc.spec.template.spec.containers[i]["truename"];                delete clonedc.spec.template.spec.containers[i]["yesimage"];                delete clonedc.spec.template.spec.containers[i]["ref"];                delete clonedc.spec.template.spec.containers[i]["tag"];                delete clonedc.spec.template.spec.containers[i]["isshow"];                arrimgs.push(clonedc.spec.template.spec.containers[i].isimageChange);                delete clonedc.spec.template.spec.containers[i]["isimageChange"];                if (clonedc.spec.template.spec.containers[i].ports) {                    delete clonedc.spec.template.spec.containers[i]["ports"];                }                if (clonedc.spec.template.spec.containers[i].env.length == 0) {                    delete clonedc.spec.template.spec.containers[i]["env"];                }                if (clonedc.spec.template.spec.containers[i].imagePullSecrets) {                    $scope.grid.imagePullSecrets = true;                    var flog = true;                    var imgps = [                        {                            "name": "registry-dockercfg-" + $rootScope.user.metadata.name                        }                    ]                    angular.forEach($scope.serviceas.imagePullSecrets, function (v, k) {                        if (v.name == imgps[0].name) {                            flog = false;                        }                    })                    if (flog) {                        clonedc.spec.template.spec.imagePullSecrets = imgps.concat($scope.serviceas.imagePullSecrets);                    } else {                        clonedc.spec.template.spec.imagePullSecrets = $scope.serviceas.imagePullSecrets;                    }                    delete clonedc.spec.template.spec.containers[i]["imagePullSecrets"];                }            }            //if ($scope.grid.imagePullSecrets) {            //    var nameandps = localStorage.getItem("Auth");            //    var newnameandps = $base64.decode(nameandps);            //    var registryobjs = {            //        "registry.dataos.io": {            //            "auth": nameandps,            //            "email": "builder@registry.dataos.io",            //            "password": newnameandps.split(':')[1],            //            "username": newnameandps.split(':')[0]            //        }            //    }            //    registryobjs = JSON.stringify(registryobjs)            //    var isdockercfg = $base64.encode(registryobjs);            //} else {            delete dc.spec.template.spec["imagePullSecrets"];            //}            var arrimgstr = arrimgs.join();            arrisshow = arrisshow.join();            clonedc.metadata.annotations["dadafoundry.io/imageorpublic"] = arrimgstr;            clonedc.metadata.annotations["dadafoundry.io/imageorisshow"] = arrisshow;            var isport = false;            for (var i = 0; i < $scope.portsArr.length; i++) {                if ($scope.portsArr[i].hostPort) {                    isport = true;                    break;                }            }            if (isport) {                createService(dc);            }            //if ($scope.grid.route) {            //    //console.log('$scope.grid.port',$scope.grid.port);            //    createRoute(dc);            //}            var createDcfn = function () {                DeploymentConfig.create({                    namespace: $rootScope.namespace                }, clonedc, function (res) {                    $state.go('service_detil', {name: dc.metadata.name});                }, function (res) {                    if (res.status == 409) {                    }                });            }            //if ($scope.grid.imagePullSecrets) {            //    var secretsobj = {            //        "kind": "Secret",            //        "apiVersion": "v1",            //        "metadata": {            //            "name": "registry-dockercfg-" + $rootScope.namespace            //        },            //        "data": {            //            ".dockercfg": isdockercfg            //        },            //        "type": "kubernetes.io/dockercfg"            //    }            //    secretskey.create({            //        namespace: $rootScope.namespace            //    }, secretsobj, function (res) {            //        createDcfn();            //    }, function (res) {            //        if (res.status == 409) {            //            createDcfn();            //        }            //    })            //} else {            createDcfn();            //}        };    }})();