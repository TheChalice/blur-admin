/** * Created by sorcerer on 2017/5/24. */(function () {    'use strict';    angular.module('BlurAdmin.service', [])        .constant('AUTH_EVENTS', {            loginNeeded: 'auth-login-needed',            loginSuccess: 'auth-login-success',            httpForbidden: 'auth-http-forbidden'        })        .constant('GLOBAL', {            size: 10,            host: '/oapi/v1',            host_k8s: '/api/v1',            host_wss: '/ws/oapi/v1',            host_wss_k8s: '/ws/api/v1',            host_registry: '/registry/api',            host_newk8s: '/apis/autoscaling/v1',            login_uri: '/login',            signin_uri: '/signin',            host_lapi: '/lapi',            common_url:'registry.dataos.io',            service_url:'.cloud.new.dataos.io',            host_hawkular: '/hawkular/metrics',            host_webhooks: 'https://dev.dataos.io:8443',            host_payment: '/payment/v1'        })        .config(['$httpProvider', 'GLOBAL', function ($httpProvider) {            $httpProvider.interceptors.push([                '$injector',                function ($injector) {                    return $injector.get('AuthInterceptor');                }            ]);        }])        .service('Cookie', [function () {            this.set = function (key, val, expires) {                var date = new Date();                date.setTime(date.getTime() + expires);                document.cookie = key + "=" + val + "; expires=" + date.toUTCString();            };            this.get = function (key) {                var reg = new RegExp("(^| )" + key + "=([^;]*)(;|$)");                var arr = document.cookie.match(reg);                if (arr) {                    return (arr[2]);                }                return null            };            this.clear = function (key) {                this.set(key, "", -1);            };        }])        .service('MetricsService', [function () {            var midTime = function (point) {                return point.start + (point.end - point.start) / 2;            };            var millicoresUsed = function (point, lastValue) {                if (!lastValue || !point.value) {                    return null;                }                if (lastValue > point.value) {                    return null;                }                var timeInMillis = point.end - point.start;                var usageInMillis = (point.value - lastValue) / 1000000;                return (usageInMillis / timeInMillis) * 1000;            };            this.normalize = function (data, metric) {                var lastValue;                angular.forEach(data, function (point) {                    var value;                    if (!point.timestamp) {                        point.timestamp = midTime(point);                    }                    if (!point.value || point.value === "NaN") {                        var avg = point.avg;                        point.value = (avg && avg !== "NaN") ? avg : null;                    }                    if (metric === 'CPU') {                        value = point.value;                        point.value = millicoresUsed(point, lastValue);                        lastValue = value;                    }                });                data.shift();                return data;            };        }])        .factory('AuthInterceptor', ['$rootScope', '$q', 'AUTH_EVENTS', 'Cookie', function ($rootScope, $q, AUTH_EVENTS, Cookie) {            var CODE_MAPPING = {                401: AUTH_EVENTS.loginNeeded,                403: AUTH_EVENTS.httpForbidden,                419: AUTH_EVENTS.loginNeeded,                440: AUTH_EVENTS.loginNeeded            };            return {                request: function (config) {                    if (/^\/signin/.test(config.url)) {                        return config;                    }                    //$rootScope.region=                    var token = Cookie.get('df_access_token');                    //console.log('config.headers',config.headers);                    if (config.headers && token) {                        config.headers["Authorization"] = "Bearer " + token;                    }                    if (/^\/hawkular/.test(config.url)) {                        config.headers["Hawkular-Tenant"] = $rootScope.namespace;                    }                    if (/^\/registry/.test(config.url)) {                        //var Auth = localStorage.getItem("Auth")                        config.headers["Authorization"] = "Basic " + Auth;                    }                    if (config.method == 'PATCH') {                        config.headers["Content-Type"] = "application/merge-patch+json";                    }                    //$rootScope.loading = true;                    return config                },                requestError: function (rejection) {                    //$rootScope.loading = false;                    return $q.reject(rejection);                },                response: function (res) {                    //$rootScope.loading = false;                    return res;                },                responseError: function (response) {                    //alert(11)                    //$rootScope.loading = false;                    var val = CODE_MAPPING[response.status];                    if (val) {                        $rootScope.$broadcast(val, response);                    }                    return $q.reject(response);                }            };        }])        .service('Sort', [function () {            this.sort = function (items, reverse) {                if (!reverse || reverse == 0) {                    reverse = 1;                }                items.sort(function (a, b) {                    if (!a.metadata) {                        return 0;                    }                    return reverse * ((new Date(a.metadata.creationTimestamp)).getTime() - (new Date(b.metadata.creationTimestamp)).getTime());                });                return items;            };        }])        .service('Confirm', ['$uibModal', function ($uibModal) {            this.open = function (title, txt, tip, tp, iscf) {                return $uibModal.open({                    templateUrl: 'app/pages/public/tpl/confirm.html',                    size: 'default',                    controller: ['$scope', '$uibModalInstance', function ($scope, $uibModalInstance) {                        $scope.title = title;                        $scope.txt = txt;                        $scope.tip = tip;                        $scope.tp = tp;                        $scope.iscf = iscf;                        $scope.ok = function () {                            $uibModalInstance.close(true);                        };                        $scope.cancel = function () {                            $uibModalInstance.dismiss();                        };                    }]                }).result;            };        }])        .service('ansi_ups', ['$uibModal', function ($uibModal) {            //this.open = function (Date) {            var ansi_up,                VERSION = "1.3.0",            // check for nodeJS                hasModule = (typeof module !== 'undefined'),            // Normal and then Bright                ANSI_COLORS = [                    [                        {color: "0, 0, 0", 'class': "ansi-black"},                        {color: "187, 0, 0", 'class': "ansi-red"},                        {color: "0, 187, 0", 'class': "ansi-green"},                        {color: "187, 187, 0", 'class': "ansi-yellow"},                        {color: "0, 0, 187", 'class': "ansi-blue"},                        {color: "187, 0, 187", 'class': "ansi-magenta"},                        {color: "0, 187, 187", 'class': "ansi-cyan"},                        {color: "255,255,255", 'class': "ansi-white"}                    ],                    [                        {color: "85, 85, 85", 'class': "ansi-bright-black"},                        {color: "255, 85, 85", 'class': "ansi-bright-red"},                        {color: "0, 255, 0", 'class': "ansi-bright-green"},                        {color: "255, 255, 85", 'class': "ansi-bright-yellow"},                        {color: "85, 85, 255", 'class': "ansi-bright-blue"},                        {color: "255, 85, 255", 'class': "ansi-bright-magenta"},                        {color: "85, 255, 255", 'class': "ansi-bright-cyan"},                        {color: "255, 255, 255", 'class': "ansi-bright-white"}                    ]                ],            // 256 Colors Palette                PALETTE_COLORS;            function Ansi_Up() {                this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;                this.bright = 0;            }            Ansi_Up.prototype.setup_palette = function () {                PALETTE_COLORS = [];                // Index 0..15 : System color                (function () {                    var i, j;                    for (i = 0; i < 2; ++i) {                        for (j = 0; j < 8; ++j) {                            PALETTE_COLORS.push(ANSI_COLORS[i][j]['color']);                        }                    }                })();                // Index 16..231 : RGB 6x6x6                // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml                (function () {                    var levels = [0, 95, 135, 175, 215, 255];                    var format = function (r, g, b) {                        return levels[r] + ', ' + levels[g] + ', ' + levels[b]                    };                    var r, g, b;                    for (r = 0; r < 6; ++r) {                        for (g = 0; g < 6; ++g) {                            for (b = 0; b < 6; ++b) {                                PALETTE_COLORS.push(format.call(this, r, g, b));                            }                        }                    }                })();                // Index 232..255 : Grayscale                (function () {                    var level = 8;                    var format = function (level) {                        return level + ', ' + level + ', ' + level                    };                    var i;                    for (i = 0; i < 24; ++i, level += 10) {                        PALETTE_COLORS.push(format.call(this, level));                    }                })();            };            Ansi_Up.prototype.escape_for_html = function (txt) {                return txt.replace(/[&<>]/gm, function (str) {                    if (str == "&") return "&amp;";                    if (str == "<") return "&lt;";                    if (str == ">") return "&gt;";                });            };            Ansi_Up.prototype.linkify = function (txt) {                return txt.replace(/(https?:\/\/[^\s]+)/gm, function (str) {                    return "<a href=\"" + str + "\">" + str + "</a>";                });            };            Ansi_Up.prototype.ansi_to_html = function (txt, options) {                return this.process(txt, options, true);            };            Ansi_Up.prototype.ansi_to_text = function (txt) {                var options = {};                return this.process(txt, options, false);            };            Ansi_Up.prototype.process = function (txt, options, markup) {                var self = this;                if (txt) {                    var raw_text_chunks = txt.split(/\033\[/);                    var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split                    var color_chunks = raw_text_chunks.map(function (chunk) {                        return self.process_chunk(chunk, options, markup);                    });                    color_chunks.unshift(first_chunk);                    return color_chunks.join('');                }            };            Ansi_Up.prototype.process_chunk = function (text, options, markup) {                // Are we using classes or styles?                options = typeof options == 'undefined' ? {} : options;                var use_classes = typeof options.use_classes != 'undefined' && options.use_classes;                var key = use_classes ? 'class' : 'color';                // Each 'chunk' is the text after the CSI (ESC + '[') and before the next CSI/EOF.                //                // This regex matches four groups within a chunk.                //                // The first and third groups match code type.                // We supported only SGR command. It has empty first group and 'm' in third.                //                // The second group matches all of the number+semicolon command sequences                // before the 'm' (or other trailing) character.                // These are the graphics or SGR commands.                //                // The last group is the text (including newlines) that is colored by                // the other group's commands.                var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);                if (!matches) return text;                var orig_txt = matches[4];                var nums = matches[2].split(';');                // We currently support only "SGR" (Select Graphic Rendition)                // Simply ignore if not a SGR command.                if (matches[1] !== '' || matches[3] !== 'm') {                    return orig_txt;                }                if (!markup) {                    return orig_txt;                }                var self = this;                while (nums.length > 0) {                    var num_str = nums.shift();                    var num = parseInt(num_str);                    if (isNaN(num) || num === 0) {                        self.fg = self.bg = null;                        self.bright = 0;                    } else if (num === 1) {                        self.bright = 1;                    } else if (num == 39) {                        self.fg = null;                    } else if (num == 49) {                        self.bg = null;                    } else if ((num >= 30) && (num < 38)) {                        self.fg = ANSI_COLORS[self.bright][(num % 10)][key];                    } else if ((num >= 90) && (num < 98)) {                        self.fg = ANSI_COLORS[1][(num % 10)][key];                    } else if ((num >= 40) && (num < 48)) {                        self.bg = ANSI_COLORS[0][(num % 10)][key];                    } else if ((num >= 100) && (num < 108)) {                        self.bg = ANSI_COLORS[1][(num % 10)][key];                    } else if (num === 38 || num === 48) { // extend color (38=fg, 48=bg)                        (function () {                            var is_foreground = (num === 38);                            if (nums.length >= 1) {                                var mode = nums.shift();                                if (mode === '5' && nums.length >= 1) { // palette color                                    var palette_index = parseInt(nums.shift());                                    if (palette_index >= 0 && palette_index <= 255) {                                        if (!use_classes) {                                            if (!PALETTE_COLORS) {                                                self.setup_palette.call(self);                                            }                                            if (is_foreground) {                                                self.fg = PALETTE_COLORS[palette_index];                                            } else {                                                self.bg = PALETTE_COLORS[palette_index];                                            }                                        } else {                                            var klass = (palette_index >= 16)                                                ? ('ansi-palette-' + palette_index)                                                : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]['class'];                                            if (is_foreground) {                                                self.fg = klass;                                            } else {                                                self.bg = klass;                                            }                                        }                                    }                                } else if (mode === '2' && nums.length >= 3) { // true color                                    var r = parseInt(nums.shift());                                    var g = parseInt(nums.shift());                                    var b = parseInt(nums.shift());                                    if ((r >= 0 && r <= 255) && (g >= 0 && g <= 255) && (b >= 0 && b <= 255)) {                                        var color = r + ', ' + g + ', ' + b;                                        if (!use_classes) {                                            if (is_foreground) {                                                self.fg = color;                                            } else {                                                self.bg = color;                                            }                                        } else {                                            if (is_foreground) {                                                self.fg = 'ansi-truecolor';                                                self.fg_truecolor = color;                                            } else {                                                self.bg = 'ansi-truecolor';                                                self.bg_truecolor = color;                                            }                                        }                                    }                                }                            }                        })();                    }                }                if ((self.fg === null) && (self.bg === null)) {                    return orig_txt;                } else {                    var styles = [];                    var classes = [];                    var data = {};                    var render_data = function (data) {                        var fragments = [];                        var key;                        for (key in data) {                            if (data.hasOwnProperty(key)) {                                fragments.push('data-' + key + '="' + this.escape_for_html(data[key]) + '"');                            }                        }                        return fragments.length > 0 ? ' ' + fragments.join(' ') : '';                    };                    if (self.fg) {                        if (use_classes) {                            classes.push(self.fg + "-fg");                            if (self.fg_truecolor !== null) {                                data['ansi-truecolor-fg'] = self.fg_truecolor;                                self.fg_truecolor = null;                            }                        } else {                            styles.push("color:rgb(" + self.fg + ")");                        }                    }                    if (self.bg) {                        if (use_classes) {                            classes.push(self.bg + "-bg");                            if (self.bg_truecolor !== null) {                                data['ansi-truecolor-bg'] = self.bg_truecolor;                                self.bg_truecolor = null;                            }                        } else {                            styles.push("background-color:rgb(" + self.bg + ")");                        }                    }                    if (use_classes) {                        return '<span class="' + classes.join(' ') + '"' + render_data.call(self, data) + '>' + orig_txt + '</span>';                    } else {                        return '<span style="' + styles.join(';') + '"' + render_data.call(self, data) + '>' + orig_txt + '</span>';                    }                }            };            // Module exports            //ansi_up = {            this.escape_for_html = function (txt) {                var a2h = new Ansi_Up();                return a2h.escape_for_html(txt);            };            this.linkify = function (txt) {                var a2h = new Ansi_Up();                return a2h.linkify(txt);            };            this.ansi_to_html = function (txt, options) {                var a2h = new Ansi_Up();                return a2h.ansi_to_html(txt, options);            };            this.ansi_to_text = function (txt) {                var a2h = new Ansi_Up();                return a2h.ansi_to_text(txt);            };            this.ansi_to_html_obj = function () {                return new Ansi_Up();            }            //};            // CommonJS module is defined            if (hasModule) {                return ansi_up;            }            /*global ender:false */            if (typeof window !== 'undefined' && typeof ender === 'undefined') {                window.ansi_up = ansi_up;            }            /*global define:false */            if (typeof define === "function" && define.amd) {                define("ansi_up", [], function () {                    return ansi_up;                });            }            //}        }])        .service('ContainerModal', ['$uibModal', function ($uibModal) {            this.open = function (pod, obj) {                return $uibModal.open({                    templateUrl: 'app/pages/public/tpl/containerModal.html',                    size: 'default modal-lg',                    backdrop: 'static',                    keyboard: false,                    controller: ['$base64', '$sce', 'ansi_ups', '$rootScope', '$scope', '$log', '$uibModalInstance', 'ImageStream', 'Pod', 'Ws', 'Metrics', 'MetricsService',                        function ($base64, $sce, ansi_ups, $rootScope, $scope, $log, $uibModalInstance, ImageStream, Pod, Ws, Metrics, MetricsService) {                            $scope.pod = pod;                            //console.log("pod-=-=-=-=-!!!!", pod);                            $scope.grid = {                                show: false,                                mem: false,                                cpu: false                            };                            var loglast = function () {                                setTimeout(function () {                                    $('#sc').scrollTop(1000000);                                }, 200)                            }                            $scope.ok = function () {                                $uibModalInstance.close(true);                            };                            $scope.cancel = function () {                                $uibModalInstance.dismiss();                            };                            var imageStreamName = function (image) {                                if (!image) {                                    return "";                                }                                var match = image.match(/\/([^/]*)@sha256/);                                if (!match) {                                    return image.split(":");                                }                                return match[1];                            };                            //console.log($scope.container);                            var preparePod = function (pod) {                                var status = pod.status.containerStatuses;                                var statusMap = {};                                for (var i = 0; i < status.length; i++) {                                    statusMap[status[i].name] = status[i];                                }                                var containers = pod.spec.containers;                                angular.forEach(pod.spec.containers, function (container) {                                    if (statusMap[container.name]) {                                        container.status = statusMap[container.name];                                    }                                    if (container.image.indexOf('@') != -1) {                                        ImageStream.get({                                            namespace: $rootScope.namespace,                                            name: imageStreamName(container.image),                                            region: $rootScope.region                                        }, function (res) {                                            if (res.kind == 'ImageStream') {                                                angular.forEach(res.status.tags, function (tag) {                                                    angular.forEach(tag.items, function (item) {                                                        if (container.image.indexOf(item.image)) {                                                            container.tag = tag.tag;                                                        }                                                    });                                                });                                            }                                        });                                    } else {                                        container.tag = imageStreamName(container.image)[1];                                    }                                });                                // console.log('====', $scope.pod)                            };                            preparePod($scope.pod);                            $scope.result = '';                            var watchpod = function (resourceVersion, contair) {                                Ws.watch({                                    api: 'k8s',                                    resourceVersion: resourceVersion,                                    namespace: $rootScope.namespace,                                    type: 'pods',                                    name: $scope.pod.metadata.name + '/log',                                    pod: contair,                                    protocols: 'base64.binary.k8s.io'                                }, function (res) {                                    //console.log(res);                                    //var data = JSON.parse(res.data);                                    //updateRcs(data);                                    //console.log(data);                                    if (res.data && typeof res.data == "string") {                                        if ($base64.decode(res.data) !== undefined) {                                            //console.log('$scope.result',$scope.result);                                            $scope.result += $base64.decode(res.data);                                            var html = ansi_ups.ansi_to_html($scope.result);                                            $scope.log = $sce.trustAsHtml(html);                                            loglast()                                            $scope.$apply();                                        }                                    }                                    //loglast()                                }, function () {                                    $log.info("webSocket startRC");                                }, function () {                                    $log.info("webSocket stopRC");                                    var key = Ws.key($rootScope.namespace, 'pods', $scope.pod);                                    if (!$rootScope.watches[key] || $rootScope.watches[key].shouldClose) {                                        return;                                    }                                    //watchpod($scope.resourceVersion);                                });                            };                            //$scope.containerDetail = function (idx) {                            //var o = pod.spec.containers[idx];                            //$scope.grid.show = true;                            //};                            $scope.back = function () {                                $scope.grid.show = false;                            };                            $scope.getLog = function (container) {                                var params = {                                    namespace: $rootScope.namespace,                                    name: pod.metadata.name,                                    container: container,                                    sinceTime: $scope.grid.st ? $scope.grid.st.toISOString() : (new Date(0)).toISOString()                                };                                //console.log('container', container);                                Pod.get({                                    namespace: $rootScope.namespace,                                    name: pod.metadata.name,                                    region: $rootScope.region                                }, function (podcenter) {                                    //console.log(podcenter.metadata.resourceVersion);                                    watchpod(podcenter.metadata.resourceVersion, container)                                })                            };                            $scope.terminalSelect = function () {                                $scope.terminalTabWasSelected = true;                            };                            $scope.terminalTabWasSelected = false;                            $scope.container = obj.name;                            $scope.containername = obj.name;                            $scope.getLog(obj.name);                        }]                }).result;            };        }])        .service('ImageSelect', ['$uibModal', function ($uibModal) {            this.open = function () {                return $uibModal.open({                    templateUrl: 'app/pages/public/tpl/modal_choose_image.html',                    size: 'default modal-lg',                    controller: ['$scope', 'ImageStream', 'Cookie', 'ImageStreamTag', '$uibModalInstance', 'platformlist', 'pubregistry', 'pubregistrytag',                        function ($scope, ImageStream, Cookie, ImageStreamTag, $uibModalInstance, platformlist, pubregistry, pubregistrytag) {                            $scope.imagetype = 0;                            $scope.imageindex = null;                            $scope.imagetag = null;                            $scope.changeimagetype = function (index) {                                $scope.imageindex = null;                                $scope.imagetag = null;                                $scope.imageTags=null;                                $scope.imagetype = index;                                if (index === 0) {                                    ImageStream.get({namespace: Cookie.get('namespace')}, function (images) {                                        $scope.images = images;                                        //console.log('$scope.images', $scope.images);                                    })                                } else if (index === 1) {                                    pubregistry.get(function (data) {                                        $scope.images.items = []                                        angular.forEach(data.repositories, function (image, i) {                                            var namespace = image.split('/')[0];                                            var name = image.split('/')[1];                                            $scope.images.items.push({metadata: {name: image}, status: {                                            }})                                            pubregistrytag.get({namespace: namespace, name: name}, function (tags) {                                                $scope.images.items[i].status.tags = [];                                                //console.log('tags', tags);                                                angular.forEach(tags.tags, function (tag,k) {                                                    $scope.images.items[i].status.tags.push({tag:tag,ist: {                                                        metadata :{                                                            name:$scope.images.items[i].metadata.name + ':' + tag,                                                        },                                                        ispublicimage:true                                                    }})                                                })                                            })                                        })                                    })                                }                            }                            $scope.changeimagetype(0);                            $scope.selectImage = function (idx) {                                $scope.imageindex = idx;                                $scope.imagetag = null;                                $scope.imageTags=null;                                var image = $scope.images.items[idx];                                if ($scope.imagetype===1) {                                }else {                                    angular.forEach(image.status.tags, function (item) {                                        if (!item.ist) {                                            if (image.metadata.name) {                                                ImageStreamTag.get({                                                    namespace: Cookie.get('namespace'),                                                    name: image.metadata.name + ':' + item.tag                                                }, function (res) {                                                    item.ist = res;                                                    item.ist.ispublicimage=false;                                                }, function (res) {                                                });                                            }                                        }                                    });                                }                                $scope.imageTags = image.status.tags;                                //console.log('$scope.imageTags', $scope.imageTags);                            };                            $scope.selectVersion = function (idx) {                                $scope.imagetag = idx;                            };                            $scope.ok = function () {                                $uibModalInstance.close($scope.imageTags[$scope.imagetag].ist);                            };                            $scope.cancel = function () {                                $uibModalInstance.dismiss();                            };                        }],                    resolve: {}                }).result;            }        }])        .directive('cCard', [function () {            return {                restrict: 'EA',                replace: true,                templateUrl: 'app/pages/public/tpl/card.html'            };        }])        .directive('tagList', [function () {            return {                restrict: 'EA',                replace: true,                templateUrl: 'app/pages/public/tpl/image_tag_list.html'            };        }])        .service('ModalPullImage', ['$rootScope', '$uibModal', function ($rootScope, $uibModal) {            this.open = function (name, yuorself) {                return $uibModal.open({                    templateUrl: 'app/pages/public/tpl/modal_pull_image.html',                    size: 'default',                    keyboard: false,                    controller: ['$scope', '$uibModalInstance', '$log','Cookie','GLOBAL',                        function ($scope, $uibModalInstance, $log,Cookie,GLOBAL) {                            $scope.copyCon = '复制';                            var names = name                            var tokens = Cookie.get('df_access_token').split(',');                            var token = tokens[0];                            if (yuorself == 'project') {                                $scope.name = name;                                $scope.privateurl = GLOBAL.private_url                                $scope.cmd = 'docker login -u '+Cookie.get('namespace')+' -p '+token+' '+GLOBAL.private_url+' && docker pull '+GLOBAL.private_url+'/' + $rootScope.namespace + '/' + $scope.name;                            } else {                                $scope.privateurl = GLOBAL.common_url                                $scope.name = name;                                $scope.cmd = 'docker pull '+GLOBAL.common_url+'/'  + $scope.name;;                            }                            $scope.cancel = function () {                                $uibModalInstance.dismiss();                            };                            $scope.success = function () {                                $log.info('Copied!');                                $scope.copyCon = '已复制';                            };                            $scope.fail = function (err) {                                $scope.tip = '该浏览器不支持复制，请手动选中输入框中内容，通过 Ctrl+C 复制';                                $log.error('Error!', err);                            };                        }]                }).result;            };        }])    /** @ngInject */})();